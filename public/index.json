[{"content":" 1. git介绍 # git是一套高效的版本管理工具，最早是因为bitkeeper同linux社区结束了合作关系，导致linus开始开发一套自己的版本管理工具。\n2. git的基本原理 # 2.1 git完整性 # 在保存到git之前，需要对数据进行内容的检验和计算，git使用的sha-1算法计算检验和，该检验和由40个字符串组成作为指纹字符串进行标识。\n2.2 文件状态 # git中的文件有三种状态\ncommited：已经被提交 staged：修改被暂存 modified：被修改 2.3 git 配置 # git的配置文件在/etc/gitconfig和~/.gitconfig 中，前者是对系统适用的配置文件，后者是对用户适用的配置文件\n下面是一个用户配置文件的例子，用于配置编辑器等\n[user] email = chengjiajun20@gmail.com name = jiajunCheng [core] editor = vim [https] postBuffer = 1048576000 [http] postBuffer = 357286400 为了对git进行配置，可以选择直接编辑此配置文件，也可以使用命令行进行配置\ngit config --global user.name \u0026#34;jiajunCheng\u0026#34; 如果要查看配置的信息 git config --list\n3. git基础使用 # 3.1 初始化仓库 # 初始化为git仓库\ngit init 添加修改的文件\ngit add . 进行commit\ngit commit -m \u0026#34;the commit message\u0026#34; 3.2 查看仓库状态 # 使用git status 可以查看仓库的状态，显示文件所在分支等情况\ngit status 3.3 忽略某些文件 # 使用.gitignore可以忽略文件使得其不被git所追踪\n# 忽略所有满足通配符的文件 *.a # 将文件设置为例外 !lib.a # 忽略根目录下的a.txt /a.txt # 忽略build文件夹下的所有文件 build/ 3.4 查看历史 # 通过git log 可以查看历史信息等\n3.5 撤销修改 # 撤销最后一次的修改\ngit commit --amend 3.6 远程仓库的管理 # 查看远程的情况\ngit remote -v 添加一个远程的源\ngit remote add \u0026gt;remote name\u0026gt; \u0026lt;remote url\u0026gt; 3.6 标签管理 # 查看标签\ngit tag 新建标签\ngit tag -a \u0026lt;tag name\u0026gt; -m \u0026lt;tag message\u0026gt; 如果不需要添加信息，可以直接使用git tag \u0026lt;tag name\u0026gt;即可\n后期对某个commit加上tag\ngit tag -a \u0026lt;tag name\u0026gt; \u0026lt;commit version\u0026gt; tag默认不会被push到远端，所以需要使用\ngit push \u0026lt;remote name\u0026gt; --tags 4. git 分支 # 4.1 分支合并 # 最简单的是使用merge进行处理，如果没有冲突的话\ngit merge \u0026lt;branch name\u0026gt; 4.2 分支删除 # git branch -d \u0026lt;branch name\u0026gt; 4.3 分支冲突 # git mergetool \u0026lt;file name\u0026gt; 4.4 使用变基的方式进行合并 # rebase是git中的一个重要的操作，使用rebase可以将部分分支的修改直接添加到当前分支上。\n假设dev分支和main分支起源于同一个commit，dev分支在此时进行了commit，main分支也进行了commit，如果此时需要将dev的修改合并到main分支上，那么此时可以\ngit checkout dev git rebase main git checkout main git merge dev 使用变基的方法需要注意的是避免对已经存储远端的提交历史进行操作\n5. 服务器上的git # 5.1 基于本地协议 # git在进行clone的时候可以使用本地的文件路径作为远端的url进行使用\n5.2 ssh协议 # 可以在前面指明使用ssh或者是使用 user@server的方式即可进行处理\n5.3 http协议 # 只需要把裸的git仓库文件放到http服务的根目录下并设置一个特定的post-update(hook)即可搞定\n6. 分布式git # 6.1 集中式工作流 # 只有一个核心仓库，每个人向其中提交代码，并从远端拉取他人的修改，是最常见的工作模式\n6.2 集成管理员工作模式 # 每个成员对应一个远程的仓库，还有一个远程的总仓库从这些远程仓库中获取更新。\n6.3 司令官与副官工作流 # 6.4 cherry-pick 获取commit # git cherry \u0026lt;commit version\u0026gt; 7. git工具 # 7.1 交互式git # 使用git add -i 可以使得git进入交互式的shell模式\n\u0026gt; git add -i staged unstaged path 1: unchanged +65/-6 content/git.md *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 1 staged unstaged path 1: unchanged +65/-6 content/git.md 7.2 暂存 # 有时候在当前分支上做了一些修改但是不希望进行commit又希望切换到其他的分支上，那么此时可以使用git stash进行暂存\n回到当前分支继续开发可以使用git stash pop, 如果想放弃这些修改，可以使用git stash drop\n7.3 子模块 # git submodule add \u0026lt;repo url\u0026gt; 克隆带子项目的仓库\ngit clone \u0026lt;repo url\u0026gt; cd \u0026lt;repo\u0026gt; # 初始化子模块 git submodule init 更新子模块\ngit submodule update ","date":"4 August 2023","permalink":"/git/","section":"My star","summary":"1.","title":"Git 入门"},{"content":"","date":"1 August 2023","permalink":"/","section":"My star","summary":"","title":"My star"},{"content":"","date":"1 August 2023","permalink":"/web/","section":"Webs","summary":"","title":"Webs"},{"content":" TCP(Transmission Control Protocol) # rfc793\nTCP的提出 # TCP的提出是作为一个的面向连接的，高可靠性的端到端之间的通信协议，其关键主要在下面的几个部分\n基础数据传输 可靠性 流量控制 多路复用 优先权和安全性 TCP的基本原理 # 1. 端口寻址 # 在网络中，通过端口去寻找对应的应用进行信息的传递\n2. 可靠性连接 # 可靠性连接，通过滑动窗口的形式进行流量的控制\n3. 连接建立和清除 # TCP通过发出和接收的端口来标识连接。\n功能规格 # 1. 报文头规格 # tcp开头第一行有两个成员：源端口号 目的端口号\n第二行为序列号，第三行为确认号\n具体内容参考文档\n2. 建立连接 # tcp在建立连接的时候需要进行三次握手，首先发出一个带SEQ的，然后返回SEQ+1的ACK，并添加一个随机的SEQ返回，随后另外一边返回ACK\n3. 关闭连接 # close表示此时没有需要传递的数据\nUDP(User Datagram Protocol) # UDP 起源 # UDP的目的是为了尽可能地传递数据报给对方。\nUDP格式 # 第一行是源端口号和目的端口号\n第二行是长度和检查和\n后面均为数据\nhttp(Hypertext transfer protocol) # 超文本传输协议是应用层的传输协议，用于分布式超媒体\nhttps # rpc(Remote Procedure Call) # rpc协议可以建立在UDP/TCP的基础上，当其建立在UDP的基础上时，它需要发展出自己的超时重传机制。\nrpc协议的需求 # 对每一个调用进行唯一的标识 将请求消息和响应消息匹配起来的规则 验证调用者和被调用者的身份 rpc程序和调用 # rpc调用信息有三个无符合整数成员\n远程程序编号 远程程序版本号 远程调用号 UDP # ","date":"1 August 2023","permalink":"/web/backend/protocol/","section":"Webs","summary":"TCP(Transmission Control Protocol) # rfc793","title":"后端相关协议"},{"content":" The computer architecture # 1. The von neumann architecture # It is a type of computer architecture that combine the program instruction memory and the data storage.\n2. evaluate the computer architecture # 2.1 non-time index # The word length of the machine. The storage size of the machine The storage bandwidth of the machine The bus width of the machine 2.2 time # The main frequency of the machine CPI: clock cycles per instruction IPC: instructions per clock cycle MIPC: million instructions per second 3.The machine number # real number: using + and - to describe the number machine number: using the 1 and 0 to describe the number origin code: $2^n - x$ inverse code: 2\u0026rsquo;s complement 原码是只使用第一位作为符号位，其他位来表示值，反码是在源码的基础上出了符号位置不变，其他位置全部取反\nFor the 2\u0026rsquo;s complement, there is only one way to describle the 0.\n3.1 data validation # code spaceing \u0026gt;= e + 1 can check e errors\ncode spaceing \u0026gt;= 2*t + 1 can repair t errors\nparity checking: for parity checking, it use an addtional position to make it number begin even or old.\n4. cpu # 5. The microinstruction # 5.1 Direct instructions format. # Each bits identify a signal. The instruction will be very long.\n5.2 coded notation # Some signal can be given together, like add and sub. 3:8 decoder can use three bits to represent 8 signals.\n","date":"13 July 2023","permalink":"/cs/arch/","section":"Cs","summary":"The computer architecture # 1.","title":"Computer architecture"},{"content":"","date":"13 July 2023","permalink":"/cs/","section":"Cs","summary":"","title":"Cs"},{"content":" 1. Application layer # 1.1 HTTP # The format of the http request message\nThe first line is the request line\n\u0026lt;HTTP method\u0026gt; url \u0026lt;HTTP version\u0026gt; shell The following lines are header lines, like\nHost: www.baidu.com The format of the http response message\nThe first line is the status line\nHTTP/1.1 200 OK The following lines are header lines, in these lines, user will be informed the Connection is closed and the server\u0026hellip;etc\n2. Transport layer # Demultiplexing takes data from different socket from the source server.\nMultiplexing takes data with header lines to generate the message.\n2.1 UDP # UDP add a little things to the ip, like the source port and the destination port.\nThe message of udp looks like this.\n|source port | destination port| |len | checksum | the real data You can examine the message of udp by checksum but you can not recover it.\n2.2 TCP # The get back N\nIn the GBN protocol, it allows the senders to send multiple packets.\n|the packets have been ack|base| the packets have been send but not ack |nextseqnum| wait to send | When the windows is full, it will not send any packets. What\u0026rsquo;s more, the GBN use the cumulative acknowledge to store the ack.\nWhen the timeout, the gbn will send all the packets it send but not ack.\nSelect Retransmission\nThe SR will only send packets that are timeout.\nThe form of the tcp message.\n|source port|dest port| | The seq | | The ACK num | Connection of the tcp.\nFirst, the client will send a specified packet to the server with a random isn called the client_isn. Then server receive the packet and send to the server with ack(client_isn + 1) and a random server_isn, it is called the syn_ack. When received the syn_ack, the client will send to the server with server_sin + 1 slow start\nAt start, it just send a packet, after they are received, it will be twice. When it get to the threshold, it will only add one at a time.\nWhen the packet is timeout, the cwnd will be set to the 1.\nQuick recovery.\n3. NetWork Layer # 3.1 Forward and routing # According to the head of the packet, it can be forward to other device.\n3.2 IPV4 # IPV4 is called the data packet.\nThe keyword in the ipv4 are as followings.\nversion:the version of the ipv4 length:the length of the packet services type: ttl: time to live protocol: when the packet arrived at the destination it will work. checksum: check the error source address target address data As the ipv4 decode.\nIt is called the dotled・decimal notation, the net address netmask means the length of the left part of the ip.\n3.3 Change of net address. # Using the nat to translate the address.\n3.4 The ipv6 # | version | type of stream | tag of stream | | payload length | the next header | the jump limit | ","date":"12 July 2023","permalink":"/cs/net/","section":"Cs","summary":"1.","title":"Computer network"},{"content":"","date":"7 July 2023","permalink":"/arch/","section":"Arches","summary":"","title":"Arches"},{"content":" Deconstructing Commit # link to the paper pdf\n1. Summary # This paper introduce the OoO commit in the cpu, which is less concerned than the OoO execution and branch prediction.\n2. position of the commit # Commit is usually is last stage of the cpu. In the commit stage the resources allocated by rob, regfile\u0026hellip; will be freed.\n3. Why commit in order? # Commit inorder can avoid many problems like waw conflict or commit the misprediction instructions.\n4. The condition for the OoO commit # 4.1 Finished the execution # Before commit the instructions, it should complete it access to all of the function units.\n4.2 WAR Hazard # A store instruction can not be commit until the load to the target register is already committed.\n4.3 on the right branch # The instruction can not be commit when it knows it is on the right branch\n4.4 there is no older instruction may raise exception # when there is no older instruction will raise exception, it can commit safely.\n4.5 Replay Traps # For a memory operation to commit early it must be known that an instruction is free from store-load and load-load replay traps.\n","date":"7 July 2023","permalink":"/arch/paper/commit/","section":"Arches","summary":"Deconstructing Commit # link to the paper pdf","title":"Deconstructing Commit"},{"content":" Image Thresholding # Simple Thresholding # For the simple thresholding process, when the pixels smaller than the threshold, it will be set to the 0, otherwise it will be set to 1.\nThere are several types of simple thresholds\nThere are several parameters.\nsrc: The image source threshold: The threshold maxThreshold: The maximum threshold Type: the type of threshold ret,thresh1 = cv.threshold(img,127,255,cv.THRESH_BINARY) ","date":"1 July 2023","permalink":"/opencv/threshold/","section":"Opencvs","summary":"Image Thresholding # Simple Thresholding # For the simple thresholding process, when the pixels smaller than the threshold, it will be set to the 0, otherwise it will be set to 1.","title":"Image Thresholding process"},{"content":"","date":"1 July 2023","permalink":"/opencv/","section":"Opencvs","summary":"","title":"Opencvs"},{"content":" Geometric Transformations of Images # 1. Transformations # cv.warpAffine and cv.warpPerspective are two functions used to transform the pictures.\nThe warpAffine can be used to rotate , translate and scale, transformed parallel lines are still parallel.\n1.1 scaling # using the cv.resize function to resize the image.\nwhen using the cv.resize function to resize the image, there are two ways.\nusing the fx and fy to scale the x and y using the shape parameter to set the x and y directly import numpy as np import cv2 as cv img = cv.imread(\u0026#39;messi5.jpg\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; res = cv.resize(img,None,fx=2, fy=2, interpolation = cv.INTER_CUBIC) #OR height, width = img.shape[:2] res = cv.resize(img,(2*width, 2*height), interpolation = cv.INTER_CUBIC) 1.2 rotation # using cv.wrapAffine to rotate the image.\nimg = cv.imread(\u0026#39;messi5.jpg\u0026#39;, cv.IMREAD_GRAYSCALE) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; rows,cols = img.shape # cols-1 and rows-1 are the coordinate limits. M = cv.getRotationMatrix2D(((cols-1)/2.0,(rows-1)/2.0),90,1) dst = cv.warpAffine(img,M,(cols,rows)) 1.3 Perspective Transformation # img = cv.imread(\u0026#39;sudoku.png\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; rows,cols,ch = img.shape pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]]) pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]]) M = cv.getPerspectiveTransform(pts1,pts2) dst = cv.warpPerspective(img,M,(300,300)) plt.subplot(121),plt.imshow(img),plt.title(\u0026#39;Input\u0026#39;) plt.subplot(122),plt.imshow(dst),plt.title(\u0026#39;Output\u0026#39;) ","date":"1 July 2023","permalink":"/opencv/transformation/","section":"Opencvs","summary":"Geometric Transformations of Images # 1.","title":"Geometric Transformations of Images"},{"content":" start process the picture # Read in the picture # using the cv2.imread you can get the img type result.\nimport cv2 import numpy as np img = cv2.imread(\u0026#39;test.png\u0026#39;) print(img) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; The default image type is the rgb\nImage add # $dst = \\beta \\cdot img1 + \\alpha\\cdot img2$\n将不同的图片按照不同的比例进行叠加，得到最终的图片\nimport cv2 as cv import numpy as np img1 = cv.imread(\u0026#39;test.png\u0026#39;) img2 = cv.imread(\u0026#39;test1.png\u0026#39;) assert img1 is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; assert img2 is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; dst = cv.addWeighted(img1, 0.7, img2, 0.3, 0) cv.imshow(\u0026#39;dst\u0026#39;, dst) cv.waitKey(0) cv.destroyAllWindows() ","date":"1 July 2023","permalink":"/opencv/imgstart/","section":"Opencvs","summary":"start process the picture # Read in the picture # using the cv2.","title":"Simple image process"},{"content":" 1. basic color model # RGB: using the (red, green, blue) to describe the color, uses 8 bits each.\nHSV: using the Hue, Saturation, and values to describe the color.\n2. Color-Space # There are many colorspaces, using the code blow to get these flags.\nimport cv2 as cv flags = [i for i in dir(cv) if i.startswith(\u0026#39;COLOR_\u0026#39;)] print(flags) 3. Object Tracking # We can change the rgb image to hsv image an extract a colored object from.\n","date":"1 July 2023","permalink":"/opencv/colorchange/","section":"Opencvs","summary":"1.","title":" Opencv colorspace change"},{"content":" Opencv environment configuration # Host information # raspberry zerow with office camera.\nTo enable the camera in the raspberry os, running the raspi-conifg command to turn on the camera.\nInstall the package # sudo apt-get install build-essential cmake pkg-config libjpeg-dev libtiff5-dev libjasper-dev libpng-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libxvidcore-dev libx264-dev libfontconfig1-dev libcairo2-dev libgdk-pixbuf2.0-dev libpango1.0-dev libgtk2.0-dev libgtk-3-dev libatlas-base-dev gfortran libhdf5-dev libhdf5-serial-dev libhdf5-103 python3-pyqt5 python3-dev -y pip3 install opencv-python It will takes a long time .\n","date":"1 July 2023","permalink":"/opencv/getstart/","section":"Opencvs","summary":"Opencv environment configuration # Host information # raspberry zerow with office camera.","title":"Opencv GetStart"},{"content":"My name is jiajunCheng\nA student from HuaZhong university of computer and science\nI use linux, chisel and golang in my life.\n","date":"29 June 2023","permalink":"/about/","section":"My star","summary":"My name is jiajunCheng","title":"About"},{"content":" The first # ","date":"29 June 2023","permalink":"/posts/my-first-post/","section":"Posts","summary":" The first # ","title":"My First Post"},{"content":"","date":"29 June 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" Image Filtering # 2D Convolution # 图像通常会被不同类型的滤波函数所处理，通常而言有两种\nlow pass filter: used to filter the image noise high pass filter: used to find edges in the image import numpy as np import cv2 as cv from matplotlib import pyplot as plt img = cv.imread(\u0026#39;test.png\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; kernel = np.ones((5, 5), np.float32) / 25 dst = cv.filter2D(img, -10, kernel) plt.subplot(121), plt.imshow(img), plt.title(\u0026#39;Original\u0026#39;) plt.xticks([]), plt.yticks([]) plt.subplot(122), plt.imshow(dst), plt.title(\u0026#39;Averaging\u0026#39;) plt.xticks([]), plt.yticks([]) plt.show() Image Bluring # ","date":"1 January 0001","permalink":"/opencv/imagefilter/","section":"Opencvs","summary":"Image Filtering # 2D Convolution # 图像通常会被不同类型的滤波函数所处理，通常而言有两种","title":""},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]