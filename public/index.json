[{"content":"","date":"1 August 2023","permalink":"/","section":"My star","summary":"","title":"My star"},{"content":"","date":"1 August 2023","permalink":"/web/","section":"Webs","summary":"","title":"Webs"},{"content":" TCP(Transmission Control Protocol) # rfc793\nTCP的提出 # TCP的提出是作为一个的面向连接的，高可靠性的端到端之间的通信协议，其关键主要在下面的几个部分\n基础数据传输 可靠性 流量控制 多路复用 优先权和安全性 TCP的基本原理 # 1. 端口寻址 # 在网络中，通过端口去寻找对应的应用进行信息的传递\n2. 可靠性连接 # 可靠性连接，通过滑动窗口的形式进行流量的控制\n3. 连接建立和清除 # TCP通过发出和接收的端口来标识连接。\n功能规格 # 1. 报文头规格 # tcp开头第一行有两个成员：源端口号 目的端口号\n第二行为序列号，第三行为确认号\n具体内容参考文档\n2. 建立连接 # tcp在建立连接的时候需要进行三次握手，首先发出一个带SEQ的，然后返回SEQ+1的ACK，并添加一个随机的SEQ返回，随后另外一边返回ACK\n3. 关闭连接 # close表示此时没有需要传递的数据\nUDP(User Datagram Protocol) # UDP 起源 # UDP的目的是为了尽可能地传递数据报给对方。\nUDP格式 # 第一行是源端口号和目的端口号\n第二行是长度和检查和\n后面均为数据\nhttp(Hypertext transfer protocol) # 超文本传输协议是应用层的传输协议，用于分布式超媒体\nhttps # rpc(Remote Procedure Call) # rpc协议可以建立在UDP/TCP的基础上，当其建立在UDP的基础上时，它需要发展出自己的超时重传机制。\nrpc协议的需求 # 对每一个调用进行唯一的标识 将请求消息和响应消息匹配起来的规则 验证调用者和被调用者的身份 rpc程序和调用 # rpc调用信息有三个无符合整数成员\n远程程序编号 远程程序版本号 远程调用号 UDP # ","date":"1 August 2023","permalink":"/web/backend/protocol/","section":"Webs","summary":"TCP(Transmission Control Protocol) # rfc793","title":"后端相关协议"},{"content":" The computer architecture # 1. The von neumann architecture # It is a type of computer architecture that combine the program instruction memory and the data storage.\n2. evaluate the computer architecture # 2.1 non-time index # The word length of the machine. The storage size of the machine The storage bandwidth of the machine The bus width of the machine 2.2 time # The main frequency of the machine CPI: clock cycles per instruction IPC: instructions per clock cycle MIPC: million instructions per second 3.The machine number # real number: using + and - to describe the number machine number: using the 1 and 0 to describe the number origin code: $2^n - x$ inverse code: 2\u0026rsquo;s complement 原码是只使用第一位作为符号位，其他位来表示值，反码是在源码的基础上出了符号位置不变，其他位置全部取反\nFor the 2\u0026rsquo;s complement, there is only one way to describle the 0.\n3.1 data validation # code spaceing \u0026gt;= e + 1 can check e errors\ncode spaceing \u0026gt;= 2*t + 1 can repair t errors\nparity checking: for parity checking, it use an addtional position to make it number begin even or old.\n4. cpu # 5. The microinstruction # 5.1 Direct instructions format. # Each bits identify a signal. The instruction will be very long.\n5.2 coded notation # Some signal can be given together, like add and sub. 3:8 decoder can use three bits to represent 8 signals.\n","date":"13 July 2023","permalink":"/cs/arch/","section":"Cs","summary":"The computer architecture # 1.","title":"Computer architecture"},{"content":"","date":"13 July 2023","permalink":"/cs/","section":"Cs","summary":"","title":"Cs"},{"content":" 1. Application layer # 1.1 HTTP # The format of the http request message\nThe first line is the request line\n\u0026lt;HTTP method\u0026gt; url \u0026lt;HTTP version\u0026gt; shell The following lines are header lines, like\nHost: www.baidu.com The format of the http response message\nThe first line is the status line\nHTTP/1.1 200 OK The following lines are header lines, in these lines, user will be informed the Connection is closed and the server\u0026hellip;etc\n2. Transport layer # Demultiplexing takes data from different socket from the source server.\nMultiplexing takes data with header lines to generate the message.\n2.1 UDP # UDP add a little things to the ip, like the source port and the destination port.\nThe message of udp looks like this.\n|source port | destination port| |len | checksum | the real data You can examine the message of udp by checksum but you can not recover it.\n2.2 TCP # The get back N\nIn the GBN protocol, it allows the senders to send multiple packets.\n|the packets have been ack|base| the packets have been send but not ack |nextseqnum| wait to send | When the windows is full, it will not send any packets. What\u0026rsquo;s more, the GBN use the cumulative acknowledge to store the ack.\nWhen the timeout, the gbn will send all the packets it send but not ack.\nSelect Retransmission\nThe SR will only send packets that are timeout.\nThe form of the tcp message.\n|source port|dest port| | The seq | | The ACK num | Connection of the tcp.\nFirst, the client will send a specified packet to the server with a random isn called the client_isn. Then server receive the packet and send to the server with ack(client_isn + 1) and a random server_isn, it is called the syn_ack. When received the syn_ack, the client will send to the server with server_sin + 1 slow start\nAt start, it just send a packet, after they are received, it will be twice. When it get to the threshold, it will only add one at a time.\nWhen the packet is timeout, the cwnd will be set to the 1.\nQuick recovery.\n3. NetWork Layer # 3.1 Forward and routing # According to the head of the packet, it can be forward to other device.\n3.2 IPV4 # IPV4 is called the data packet.\nThe keyword in the ipv4 are as followings.\nversion:the version of the ipv4 length:the length of the packet services type: ttl: time to live protocol: when the packet arrived at the destination it will work. checksum: check the error source address target address data As the ipv4 decode.\nIt is called the dotled・decimal notation, the net address netmask means the length of the left part of the ip.\n3.3 Change of net address. # Using the nat to translate the address.\n3.4 The ipv6 # | version | type of stream | tag of stream | | payload length | the next header | the jump limit | ","date":"12 July 2023","permalink":"/cs/net/","section":"Cs","summary":"1.","title":"Computer network"},{"content":"","date":"7 July 2023","permalink":"/arch/","section":"Arches","summary":"","title":"Arches"},{"content":" Deconstructing Commit # link to the paper pdf\n1. Summary # This paper introduce the OoO commit in the cpu, which is less concerned than the OoO execution and branch prediction.\n2. position of the commit # Commit is usually is last stage of the cpu. In the commit stage the resources allocated by rob, regfile\u0026hellip; will be freed.\n3. Why commit in order? # Commit inorder can avoid many problems like waw conflict or commit the misprediction instructions.\n4. The condition for the OoO commit # 4.1 Finished the execution # Before commit the instructions, it should complete it access to all of the function units.\n4.2 WAR Hazard # A store instruction can not be commit until the load to the target register is already committed.\n4.3 on the right branch # The instruction can not be commit when it knows it is on the right branch\n4.4 there is no older instruction may raise exception # when there is no older instruction will raise exception, it can commit safely.\n4.5 Replay Traps # For a memory operation to commit early it must be known that an instruction is free from store-load and load-load replay traps.\n","date":"7 July 2023","permalink":"/arch/paper/commit/","section":"Arches","summary":"Deconstructing Commit # link to the paper pdf","title":"Deconstructing Commit"},{"content":" Image Thresholding # Simple Thresholding # For the simple thresholding process, when the pixels smaller than the threshold, it will be set to the 0, otherwise it will be set to 1.\nThere are several types of simple thresholds\nThere are several parameters.\nsrc: The image source threshold: The threshold maxThreshold: The maximum threshold Type: the type of threshold ret,thresh1 = cv.threshold(img,127,255,cv.THRESH_BINARY) ","date":"1 July 2023","permalink":"/opencv/threshold/","section":"Opencvs","summary":"Image Thresholding # Simple Thresholding # For the simple thresholding process, when the pixels smaller than the threshold, it will be set to the 0, otherwise it will be set to 1.","title":"Image Thresholding process"},{"content":"","date":"1 July 2023","permalink":"/opencv/","section":"Opencvs","summary":"","title":"Opencvs"},{"content":" Geometric Transformations of Images # 1. Transformations # cv.warpAffine and cv.warpPerspective are two functions used to transform the pictures.\nThe warpAffine can be used to rotate , translate and scale, transformed parallel lines are still parallel.\n1.1 scaling # using the cv.resize function to resize the image.\nwhen using the cv.resize function to resize the image, there are two ways.\nusing the fx and fy to scale the x and y using the shape parameter to set the x and y directly import numpy as np import cv2 as cv img = cv.imread(\u0026#39;messi5.jpg\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; res = cv.resize(img,None,fx=2, fy=2, interpolation = cv.INTER_CUBIC) #OR height, width = img.shape[:2] res = cv.resize(img,(2*width, 2*height), interpolation = cv.INTER_CUBIC) 1.2 rotation # using cv.wrapAffine to rotate the image.\nimg = cv.imread(\u0026#39;messi5.jpg\u0026#39;, cv.IMREAD_GRAYSCALE) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; rows,cols = img.shape # cols-1 and rows-1 are the coordinate limits. M = cv.getRotationMatrix2D(((cols-1)/2.0,(rows-1)/2.0),90,1) dst = cv.warpAffine(img,M,(cols,rows)) 1.3 Perspective Transformation # img = cv.imread(\u0026#39;sudoku.png\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; rows,cols,ch = img.shape pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]]) pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]]) M = cv.getPerspectiveTransform(pts1,pts2) dst = cv.warpPerspective(img,M,(300,300)) plt.subplot(121),plt.imshow(img),plt.title(\u0026#39;Input\u0026#39;) plt.subplot(122),plt.imshow(dst),plt.title(\u0026#39;Output\u0026#39;) ","date":"1 July 2023","permalink":"/opencv/transformation/","section":"Opencvs","summary":"Geometric Transformations of Images # 1.","title":"Geometric Transformations of Images"},{"content":" start process the picture # Read in the picture # using the cv2.imread you can get the img type result.\nimport cv2 import numpy as np img = cv2.imread(\u0026#39;test.png\u0026#39;) print(img) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; The default image type is the rgb\nImage add # $dst = \\beta \\cdot img1 + \\alpha\\cdot img2$\n将不同的图片按照不同的比例进行叠加，得到最终的图片\nimport cv2 as cv import numpy as np img1 = cv.imread(\u0026#39;test.png\u0026#39;) img2 = cv.imread(\u0026#39;test1.png\u0026#39;) assert img1 is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; assert img2 is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; dst = cv.addWeighted(img1, 0.7, img2, 0.3, 0) cv.imshow(\u0026#39;dst\u0026#39;, dst) cv.waitKey(0) cv.destroyAllWindows() ","date":"1 July 2023","permalink":"/opencv/imgstart/","section":"Opencvs","summary":"start process the picture # Read in the picture # using the cv2.","title":"Simple image process"},{"content":" 1. basic color model # RGB: using the (red, green, blue) to describe the color, uses 8 bits each.\nHSV: using the Hue, Saturation, and values to describe the color.\n2. Color-Space # There are many colorspaces, using the code blow to get these flags.\nimport cv2 as cv flags = [i for i in dir(cv) if i.startswith(\u0026#39;COLOR_\u0026#39;)] print(flags) 3. Object Tracking # We can change the rgb image to hsv image an extract a colored object from.\n","date":"1 July 2023","permalink":"/opencv/colorchange/","section":"Opencvs","summary":"1.","title":" Opencv colorspace change"},{"content":" Opencv environment configuration # Host information # raspberry zerow with office camera.\nTo enable the camera in the raspberry os, running the raspi-conifg command to turn on the camera.\nInstall the package # sudo apt-get install build-essential cmake pkg-config libjpeg-dev libtiff5-dev libjasper-dev libpng-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libxvidcore-dev libx264-dev libfontconfig1-dev libcairo2-dev libgdk-pixbuf2.0-dev libpango1.0-dev libgtk2.0-dev libgtk-3-dev libatlas-base-dev gfortran libhdf5-dev libhdf5-serial-dev libhdf5-103 python3-pyqt5 python3-dev -y pip3 install opencv-python It will takes a long time .\n","date":"1 July 2023","permalink":"/opencv/getstart/","section":"Opencvs","summary":"Opencv environment configuration # Host information # raspberry zerow with office camera.","title":"Opencv GetStart"},{"content":"My name is jiajunCheng\nA student from HuaZhong university of computer and science\nI use linux, chisel and golang in my life.\n","date":"29 June 2023","permalink":"/about/","section":"My star","summary":"My name is jiajunCheng","title":"About"},{"content":" The first # ","date":"29 June 2023","permalink":"/posts/my-first-post/","section":"Posts","summary":" The first # ","title":"My First Post"},{"content":"","date":"29 June 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" Image Filtering # 2D Convolution # 图像通常会被不同类型的滤波函数所处理，通常而言有两种\nlow pass filter: used to filter the image noise high pass filter: used to find edges in the image import numpy as np import cv2 as cv from matplotlib import pyplot as plt img = cv.imread(\u0026#39;test.png\u0026#39;) assert img is not None, \u0026#34;file could not be read, check with os.path.exists()\u0026#34; kernel = np.ones((5, 5), np.float32) / 25 dst = cv.filter2D(img, -10, kernel) plt.subplot(121), plt.imshow(img), plt.title(\u0026#39;Original\u0026#39;) plt.xticks([]), plt.yticks([]) plt.subplot(122), plt.imshow(dst), plt.title(\u0026#39;Averaging\u0026#39;) plt.xticks([]), plt.yticks([]) plt.show() Image Bluring # ","date":"1 January 0001","permalink":"/opencv/imagefilter/","section":"Opencvs","summary":"Image Filtering # 2D Convolution # 图像通常会被不同类型的滤波函数所处理，通常而言有两种","title":""},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]